For this assignment I added the following functionality to the MME565 module. A vertex class was added and during polygon creation, each polygon point is assigned a vertex object. The vertex has properties to keep track of its convex-ness and the type (i - vi). There are methods in the class that check for convex and classify each vertex during polygon creation.

The segment class gained a mid-point property. The mid-point property will be needed later during path finding.

A function to compute the intersection between two lines was added. This will be needed in the sweeping trapezoidation algorithm.

A trapezoid class was added to create trapezoid objects during the trapezoidation routine. Trapezoids are similar to polygons and could probably become a sub-class. Trapezoids are made of vertex objects and segment objects. They also have a center-point property which will be needed later during path finding.

Trapezoidation function was added to the main body of the module. The function follows the left-to-right sweeping segment method outlined in LRPK 2.2.2. The algorithm is roughly:

Trapezoidation Pseudocode:
sort polygon segments from left (small x) to right (large x)
for each vertex from left to right:
    check vertex type (i - vi)
        add or remove segments from "S" list as dictated by LRPK
        add trapezoids to "T" list as dictated by LRPK
        update points which intersect sweeping segment

E2-9.py creates the free workspace and obstacle polygon, then creates a list of trapezoid objects using the MME565.trapezoidation function. It also plots the free workspace and the polygon, plotting important features of the polygon in separate plots so that each polygon algorithm can be checked.


E2.3
i. 4 vertices and 7 edges.

ii. Informally: It is not possible to find a path which visits each of the landmasses while only crossing each bridge once because the parallel bridges bring you back to a landmass with no feasible exit.

iii. Adding a third parallel bridge to either of the rivers with two parallel bridges would allow you top visit each landmass while only crossing each bridge once. I can't find a solution where there are only parallel bridges with even counts. I believe that there must be an odd number of bridges in at least one of the parallel set ups.

E2.8



E2.9
i.

convex / non-convex:
for each vertex in a given polygon (proceeding around the polygon in a given direction):
    measure the angle from the segment ahead of to the segment behind the vertex
    if the angle is less than \pi:
        classify the vertex as convex
    otherwise:
        classify the vertex as non-convex

vertex type (i - vi):
for each vertex in a given polygon (in any order):
    if the vertex is convex:
        if the vertex's x-coordinate is less than both of the x-coordinates of its two segments (left/left):
            classify the vertex as type "i"
        if the vertex's x-coordinate is more than both of the x-coordinates of its two segments (right/right):
            classify the vertex as type "iii"
        otherwise (left/right):
            classify the vertex as type "v"
    if the vertex is non-convex:
        if the vertex's x-coordinate is less than both of the x-coordinates of its two segments (left/left):
            classify the vertex as type "ii"
        if the vertex's x-coordinate is more than both of the x-coordinates of its two segments (right/right):
            classify the vertex as type "iv"
        otherwise (left/right):
            classify the vertex as type "vi"

ii.

Current state of trapezoidation: The program can build the free workspace and the polygon object. It can classify each vertex of the obstacle as the correct type. It can put the vertices of the obstacle in order from left to right (small x to big x). It can iterate over the ordered vertices and update "S" correctly.